'use client';

import { useCallback, useState } from 'react';
import type { FabricCanvasJSON, AspectRatioKey, SafeZone } from '../types';
import { ASPECT_RATIOS, parseAspectRatio } from '../types';

/**
 * Data stored for each aspect ratio variant
 */
interface VariantData {
  canvasJson: FabricCanvasJSON;
  isAutoGenerated: boolean;
  thumbnailUrl?: string;
  safeZone: SafeZone;
}

/**
 * Options for the useAspectRatioVariants hook
 */
interface UseAspectRatioVariantsOptions {
  /** The primary aspect ratio (source for auto-generation) */
  primaryRatio: AspectRatioKey;
  /** The primary canvas JSON (source for auto-generation) */
  primaryCanvas: FabricCanvasJSON | null;
  /** Initial variants to populate */
  initialVariants?: Map<AspectRatioKey, VariantData>;
  /** Callback when a variant changes */
  onVariantChange?: (ratio: AspectRatioKey, variant: VariantData) => void;
}

/**
 * Return type for the useAspectRatioVariants hook
 */
export interface UseAspectRatioVariantsReturn {
  /** Map of all stored variants */
  variants: Map<AspectRatioKey, VariantData>;
  /** Currently selected aspect ratio */
  currentRatio: AspectRatioKey;
  /** Set the current aspect ratio */
  setCurrentRatio: (ratio: AspectRatioKey) => void;
  /** Generate a variant for a target ratio (does not store) */
  generateVariant: (targetRatio: AspectRatioKey) => FabricCanvasJSON | null;
  /** Set/update a variant */
  setVariant: (ratio: AspectRatioKey, data: Partial<VariantData> & { canvasJson: FabricCanvasJSON }) => void;
  /** Auto-generate and store a variant */
  autoGenerateVariant: (targetRatio: AspectRatioKey) => FabricCanvasJSON | null;
  /** Mark a variant as manually edited */
  markAsManuallyEdited: (ratio: AspectRatioKey) => void;
  /** Reset a variant to auto-generated version */
  resetToAutoGenerated: (ratio: AspectRatioKey) => void;
  /** Get canvas JSON for a specific ratio */
  getVariantCanvas: (ratio: AspectRatioKey) => FabricCanvasJSON | null;
}

/**
 * Get the numeric value of an aspect ratio
 */
function getAspectRatioValue(ratio: AspectRatioKey): number {
  const preset = ASPECT_RATIOS[ratio];
  if (preset) {
    return preset.width / preset.height;
  }
  // Parse from string if not a preset
  const { widthRatio, heightRatio } = parseAspectRatio(ratio);
  return widthRatio / heightRatio;
}

/**
 * Hook for managing aspect ratio variants with auto-generation support
 *
 * Provides functionality to:
 * - Generate scaled variants from a primary canvas
 * - Track which variants are auto-generated vs manually edited
 * - Switch between different aspect ratios
 * - Store and retrieve variant data
 *
 * @example
 * ```tsx
 * const {
 *   variants,
 *   currentRatio,
 *   setCurrentRatio,
 *   autoGenerateVariant,
 * } = useAspectRatioVariants({
 *   primaryRatio: '1:1',
 *   primaryCanvas: canvasJson,
 *   onVariantChange: (ratio, variant) => {
 *     console.log('Variant changed:', ratio, variant);
 *   },
 * });
 * ```
 */
export function useAspectRatioVariants({
  primaryRatio,
  primaryCanvas,
  initialVariants = new Map(),
  onVariantChange,
}: UseAspectRatioVariantsOptions): UseAspectRatioVariantsReturn {
  const [variants, setVariants] = useState<Map<AspectRatioKey, VariantData>>(initialVariants);
  const [currentRatio, setCurrentRatio] = useState<AspectRatioKey>(primaryRatio);

  /**
   * Generate a variant for a target aspect ratio from the primary canvas.
   * This transforms objects to fit the new canvas dimensions while maintaining
   * their relative positions and scales.
   */
  const generateVariant = useCallback((targetRatio: AspectRatioKey): FabricCanvasJSON | null => {
    if (!primaryCanvas) return null;

    const sourceRatioValue = getAspectRatioValue(primaryRatio);
    const targetRatioValue = getAspectRatioValue(targetRatio);

    // Get source dimensions
    const sourceWidth = primaryCanvas.width ?? 1080;
    const sourceHeight = primaryCanvas.height ?? 1080;

    let newWidth: number;
    let newHeight: number;

    if (targetRatioValue > sourceRatioValue) {
      // Target is wider - keep width, reduce height
      newWidth = sourceWidth;
      newHeight = Math.round(sourceWidth / targetRatioValue);
    } else {
      // Target is taller or equal - keep height, reduce width
      newHeight = sourceHeight;
      newWidth = Math.round(sourceHeight * targetRatioValue);
    }

    // Calculate scale factor for objects
    const scaleX = newWidth / sourceWidth;
    const scaleY = newHeight / sourceHeight;
    const scale = Math.min(scaleX, scaleY);

    // Transform objects to fit new canvas
    const transformedObjects = (primaryCanvas.objects ?? []).map((obj) => ({
      ...obj,
      left: (obj.left ?? 0) * scale,
      top: (obj.top ?? 0) * scale,
      scaleX: (obj.scaleX ?? 1) * scale,
      scaleY: (obj.scaleY ?? 1) * scale,
    }));

    return {
      ...primaryCanvas,
      width: newWidth,
      height: newHeight,
      objects: transformedObjects,
    };
  }, [primaryCanvas, primaryRatio]);

  /**
   * Set or update a variant for a given ratio
   */
  const setVariant = useCallback((
    ratio: AspectRatioKey,
    data: Partial<VariantData> & { canvasJson: FabricCanvasJSON }
  ) => {
    const variantData: VariantData = {
      canvasJson: data.canvasJson,
      isAutoGenerated: data.isAutoGenerated ?? false,
      thumbnailUrl: data.thumbnailUrl,
      safeZone: data.safeZone ?? { top: 5, right: 5, bottom: 5, left: 5 },
    };

    setVariants((prev) => {
      const next = new Map(prev);
      next.set(ratio, variantData);
      return next;
    });

    onVariantChange?.(ratio, variantData);
  }, [onVariantChange]);

  /**
   * Auto-generate a variant and save it
   */
  const autoGenerateVariant = useCallback((targetRatio: AspectRatioKey): FabricCanvasJSON | null => {
    const generated = generateVariant(targetRatio);
    if (generated) {
      setVariant(targetRatio, {
        canvasJson: generated,
        isAutoGenerated: true,
        safeZone: { top: 5, right: 5, bottom: 5, left: 5 },
      });
    }
    return generated;
  }, [generateVariant, setVariant]);

  /**
   * Mark a variant as manually edited (no longer auto-generated)
   */
  const markAsManuallyEdited = useCallback((ratio: AspectRatioKey) => {
    setVariants((prev) => {
      const current = prev.get(ratio);
      if (!current) return prev;
      const next = new Map(prev);
      next.set(ratio, { ...current, isAutoGenerated: false });
      return next;
    });
  }, []);

  /**
   * Reset a variant to its auto-generated version
   */
  const resetToAutoGenerated = useCallback((ratio: AspectRatioKey) => {
    const generated = generateVariant(ratio);
    if (generated) {
      setVariant(ratio, {
        canvasJson: generated,
        isAutoGenerated: true,
        safeZone: { top: 5, right: 5, bottom: 5, left: 5 },
      });
    }
  }, [generateVariant, setVariant]);

  /**
   * Get canvas JSON for a specific ratio.
   * Returns primary canvas if ratio matches primary, otherwise returns stored variant.
   */
  const getVariantCanvas = useCallback((ratio: AspectRatioKey): FabricCanvasJSON | null => {
    if (ratio === primaryRatio) return primaryCanvas;
    return variants.get(ratio)?.canvasJson ?? null;
  }, [variants, primaryRatio, primaryCanvas]);

  return {
    variants,
    currentRatio,
    setCurrentRatio,
    generateVariant,
    setVariant,
    autoGenerateVariant,
    markAsManuallyEdited,
    resetToAutoGenerated,
    getVariantCanvas,
  };
}
