/**
 * Design Templates Hooks
 *
 * React hooks for managing design templates with the canvas editor.
 * Provides CRUD operations with team context support.
 */

import { useState, useCallback, useMemo } from "react";
import { createTeamApi, buildQueryString } from "../api-client";
import type { FabricCanvasJSON, AspectRatioKey, TemplateVariable, SafeZone } from "@/components/canvas-editor/types";

// ============================================================================
// Types
// ============================================================================

/**
 * Design template status
 */
export type DesignTemplateStatus = "draft" | "active" | "archived";

/**
 * Design template from API
 */
export interface DesignTemplate {
  id: string;
  teamId: string;
  name: string;
  description?: string;
  primaryAspectRatio: AspectRatioKey;
  canvasJson: FabricCanvasJSON;
  thumbnailUrl?: string;
  variables: TemplateVariable[];
  status: DesignTemplateStatus;
  createdAt: string;
  updatedAt: string;
}

/**
 * Design template with variants
 */
export interface DesignTemplateWithVariants extends DesignTemplate {
  variants: TemplateVariant[];
}

/**
 * Template aspect ratio variant
 */
export interface TemplateVariant {
  id: string;
  templateId: string;
  aspectRatio: AspectRatioKey;
  canvasJson: FabricCanvasJSON;
  safeZone?: SafeZone;
  isAutoGenerated: boolean;
  createdAt: string;
  updatedAt: string;
}

/**
 * Filters for listing design templates
 */
export interface DesignTemplateFilters {
  status?: DesignTemplateStatus;
  search?: string;
  sortBy?: "name" | "createdAt" | "updatedAt";
  sortOrder?: "asc" | "desc";
  page?: number;
  limit?: number;
}

/**
 * Input for creating a design template
 */
export interface CreateDesignTemplateInput {
  name: string;
  description?: string;
  primaryAspectRatio: AspectRatioKey;
  canvasJson: FabricCanvasJSON;
  variables?: TemplateVariable[];
}

/**
 * Input for updating a design template
 */
export interface UpdateDesignTemplateInput {
  id: string;
  name?: string;
  description?: string;
  primaryAspectRatio?: AspectRatioKey;
  canvasJson?: FabricCanvasJSON;
  variables?: TemplateVariable[];
  status?: DesignTemplateStatus;
}

/**
 * API list response
 */
interface DesignTemplateListResponse {
  data: DesignTemplate[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

// ============================================================================
// useDesignTemplates Hook
// ============================================================================

/**
 * Hook return type
 */
export interface UseDesignTemplatesReturn {
  /** List of design templates */
  templates: DesignTemplate[];
  /** Loading state */
  loading: boolean;
  /** Error message if any */
  error: string | null;
  /** Total number of templates */
  total: number;
  /** Total pages for pagination */
  totalPages: number;
  /** Current page */
  currentPage: number;
  /** Fetch templates with filters */
  fetchTemplates: (filters?: DesignTemplateFilters) => Promise<void>;
  /** Create a new template */
  createTemplate: (input: CreateDesignTemplateInput) => Promise<DesignTemplate>;
  /** Update an existing template */
  updateTemplate: (input: UpdateDesignTemplateInput) => Promise<DesignTemplate>;
  /** Delete a template */
  deleteTemplate: (id: string) => Promise<void>;
  /** Duplicate a template */
  duplicateTemplate: (id: string) => Promise<DesignTemplate>;
  /** Clear error state */
  clearError: () => void;
}

/**
 * Hook for managing design templates list
 *
 * @param teamId - The current team ID
 * @returns Templates state and operations
 *
 * @example
 * ```tsx
 * const { currentTeam } = useTeam();
 * const {
 *   templates,
 *   loading,
 *   fetchTemplates,
 *   createTemplate,
 * } = useDesignTemplates(currentTeam?.id);
 *
 * useEffect(() => {
 *   fetchTemplates({ status: 'active' });
 * }, [fetchTemplates]);
 * ```
 */
export function useDesignTemplates(
  teamId: string | undefined
): UseDesignTemplatesReturn {
  const [templates, setTemplates] = useState<DesignTemplate[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [total, setTotal] = useState(0);
  const [totalPages, setTotalPages] = useState(1);
  const [currentPage, setCurrentPage] = useState(1);

  // Create team-aware API client
  const teamApi = useMemo(() => createTeamApi(teamId), [teamId]);

  /**
   * Fetch templates with optional filters
   */
  const fetchTemplates = useCallback(
    async (filters: DesignTemplateFilters = {}) => {
      if (!teamId) {
        setError("Team context not available");
        return;
      }

      setLoading(true);
      setError(null);

      try {
        const queryParams: Record<string, string | number | undefined> = {
          page: filters.page ?? 1,
          limit: filters.limit ?? 20,
          sortBy: filters.sortBy,
          sortOrder: filters.sortOrder,
          search: filters.search,
          status: filters.status,
        };

        const queryString = buildQueryString(queryParams);
        const response = await teamApi.get<DesignTemplateListResponse>(
          `/api/v1/design-templates${queryString}`
        );

        setTemplates(response.data);
        setTotal(response.total);
        setTotalPages(response.totalPages);
        setCurrentPage(response.page);
      } catch (err) {
        const message =
          err instanceof Error ? err.message : "Failed to fetch templates";
        setError(message);
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [teamId, teamApi]
  );

  /**
   * Create a new template
   */
  const createTemplate = useCallback(
    async (input: CreateDesignTemplateInput): Promise<DesignTemplate> => {
      if (!teamId) {
        throw new Error("Team context not available");
      }

      setLoading(true);
      setError(null);

      try {
        const template = await teamApi.post<DesignTemplate>(
          "/api/v1/design-templates",
          input
        );

        // Add to local state
        setTemplates((prev) => [template, ...prev]);
        setTotal((prev) => prev + 1);

        return template;
      } catch (err) {
        const message =
          err instanceof Error ? err.message : "Failed to create template";
        setError(message);
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [teamId, teamApi]
  );

  /**
   * Update an existing template
   */
  const updateTemplate = useCallback(
    async (input: UpdateDesignTemplateInput): Promise<DesignTemplate> => {
      if (!teamId) {
        throw new Error("Team context not available");
      }

      const { id, ...body } = input;

      setLoading(true);
      setError(null);

      try {
        const template = await teamApi.put<DesignTemplate>(
          `/api/v1/design-templates/${id}`,
          body
        );

        // Update in local state
        setTemplates((prev) =>
          prev.map((t) => (t.id === id ? template : t))
        );

        return template;
      } catch (err) {
        const message =
          err instanceof Error ? err.message : "Failed to update template";
        setError(message);
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [teamId, teamApi]
  );

  /**
   * Delete a template
   */
  const deleteTemplate = useCallback(
    async (id: string): Promise<void> => {
      if (!teamId) {
        throw new Error("Team context not available");
      }

      setLoading(true);
      setError(null);

      try {
        await teamApi.delete(`/api/v1/design-templates/${id}`);

        // Remove from local state
        setTemplates((prev) => prev.filter((t) => t.id !== id));
        setTotal((prev) => Math.max(0, prev - 1));
      } catch (err) {
        const message =
          err instanceof Error ? err.message : "Failed to delete template";
        setError(message);
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [teamId, teamApi]
  );

  /**
   * Duplicate a template
   */
  const duplicateTemplate = useCallback(
    async (id: string): Promise<DesignTemplate> => {
      if (!teamId) {
        throw new Error("Team context not available");
      }

      setLoading(true);
      setError(null);

      try {
        const template = await teamApi.post<DesignTemplate>(
          `/api/v1/design-templates/${id}/duplicate`,
          {}
        );

        // Add to local state
        setTemplates((prev) => [template, ...prev]);
        setTotal((prev) => prev + 1);

        return template;
      } catch (err) {
        const message =
          err instanceof Error ? err.message : "Failed to duplicate template";
        setError(message);
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [teamId, teamApi]
  );

  /**
   * Clear error state
   */
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return {
    templates,
    loading,
    error,
    total,
    totalPages,
    currentPage,
    fetchTemplates,
    createTemplate,
    updateTemplate,
    deleteTemplate,
    duplicateTemplate,
    clearError,
  };
}

// ============================================================================
// useDesignTemplate Hook (Single Template)
// ============================================================================

/**
 * Hook return type for single template
 */
export interface UseDesignTemplateReturn {
  /** The design template */
  template: DesignTemplateWithVariants | null;
  /** Loading state */
  loading: boolean;
  /** Error message if any */
  error: string | null;
  /** Fetch the template */
  fetchTemplate: () => Promise<void>;
  /** Update the template */
  updateTemplate: (input: Omit<UpdateDesignTemplateInput, "id">) => Promise<DesignTemplate>;
  /** Upsert a variant */
  upsertVariant: (input: UpsertVariantInput) => Promise<TemplateVariant>;
  /** Clear error state */
  clearError: () => void;
}

/**
 * Input for upserting a variant
 */
export interface UpsertVariantInput {
  aspectRatio: AspectRatioKey;
  canvasJson: FabricCanvasJSON;
  safeZone?: SafeZone;
}

/**
 * Hook for managing a single design template
 *
 * @param teamId - The current team ID
 * @param templateId - The template ID to manage
 * @returns Template state and operations
 *
 * @example
 * ```tsx
 * const { currentTeam } = useTeam();
 * const {
 *   template,
 *   loading,
 *   updateTemplate,
 * } = useDesignTemplate(currentTeam?.id, templateId);
 *
 * useEffect(() => {
 *   if (currentTeam?.id && templateId) {
 *     fetchTemplate();
 *   }
 * }, [currentTeam?.id, templateId, fetchTemplate]);
 * ```
 */
export function useDesignTemplate(
  teamId: string | undefined,
  templateId: string | undefined
): UseDesignTemplateReturn {
  const [template, setTemplate] = useState<DesignTemplateWithVariants | null>(
    null
  );
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // Create team-aware API client
  const teamApi = useMemo(() => createTeamApi(teamId), [teamId]);

  /**
   * Fetch the template
   */
  const fetchTemplate = useCallback(async () => {
    if (!teamId || !templateId) {
      setError("Team or template ID not available");
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const result = await teamApi.get<DesignTemplateWithVariants>(
        `/api/v1/design-templates/${templateId}`
      );
      setTemplate(result);
    } catch (err) {
      const message =
        err instanceof Error ? err.message : "Failed to fetch template";
      setError(message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, [teamId, templateId, teamApi]);

  /**
   * Update the template
   */
  const updateTemplate = useCallback(
    async (
      input: Omit<UpdateDesignTemplateInput, "id">
    ): Promise<DesignTemplate> => {
      if (!teamId || !templateId) {
        throw new Error("Team or template ID not available");
      }

      setLoading(true);
      setError(null);

      try {
        const result = await teamApi.put<DesignTemplate>(
          `/api/v1/design-templates/${templateId}`,
          input
        );

        // Update local state
        setTemplate((prev) =>
          prev
            ? {
                ...prev,
                ...result,
              }
            : null
        );

        return result;
      } catch (err) {
        const message =
          err instanceof Error ? err.message : "Failed to update template";
        setError(message);
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [teamId, templateId, teamApi]
  );

  /**
   * Upsert a variant
   */
  const upsertVariant = useCallback(
    async (input: UpsertVariantInput): Promise<TemplateVariant> => {
      if (!teamId || !templateId) {
        throw new Error("Team or template ID not available");
      }

      setLoading(true);
      setError(null);

      try {
        const variant = await teamApi.post<TemplateVariant>(
          `/api/v1/design-templates/${templateId}/variants`,
          input
        );

        // Update local state
        setTemplate((prev) => {
          if (!prev) return null;

          const existingIndex = prev.variants.findIndex(
            (v) => v.aspectRatio === input.aspectRatio
          );

          if (existingIndex >= 0) {
            // Update existing variant
            const newVariants = [...prev.variants];
            newVariants[existingIndex] = variant;
            return { ...prev, variants: newVariants };
          } else {
            // Add new variant
            return { ...prev, variants: [...prev.variants, variant] };
          }
        });

        return variant;
      } catch (err) {
        const message =
          err instanceof Error ? err.message : "Failed to save variant";
        setError(message);
        throw err;
      } finally {
        setLoading(false);
      }
    },
    [teamId, templateId, teamApi]
  );

  /**
   * Clear error state
   */
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return {
    template,
    loading,
    error,
    fetchTemplate,
    updateTemplate,
    upsertVariant,
    clearError,
  };
}

export default useDesignTemplates;
