/**
 * Better Auth Configuration
 *
 * Provides authentication functionality using Better Auth library with:
 * - Magic link authentication (passwordless)
 * - OAuth social sign-in (Google, GitHub)
 * - Admin user management (roles, banning, session management)
 * - Session management with 7-day expiry
 * - Drizzle ORM adapter for PostgreSQL
 *
 * @see https://www.better-auth.com/docs
 */
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { magicLink, admin } from "better-auth/plugins";
import { db } from "../services/db.js";
import { sendMagicLinkEmail, type SendMagicLinkOptions } from "@repo/email";
import * as schema from "@repo/database/schema";

/**
 * Send magic link email with development fallback
 *
 * Better Auth Contract: This function must throw an error on failure.
 * - In production: Throws when email send fails
 * - In development: Logs to console as fallback (no throw, simulating success)
 *
 * Development behavior:
 * The @repo/email package validates for HTTPS URLs. Better Auth generates
 * http:// URLs in development, so we handle this by logging the URL to
 * console when the email send fails due to HTTPS validation. This allows
 * developers to test authentication by clicking the logged URL.
 */
async function sendMagicLink({
  email,
  url,
}: {
  email: string;
  url: string;
}): Promise<void> {
  const expiresAt = new Date(Date.now() + 15 * 60 * 1000); // 15 minutes

  const options: SendMagicLinkOptions = {
    to: email,
    magicLinkUrl: url,
    expiresAt,
  };

  const result = await sendMagicLinkEmail(options);

  if (!result.success) {
    // In development, the URL might be http:// which fails HTTPS validation
    // Log the magic link URL so developers can still test authentication
    if (process.env.NODE_ENV !== "production") {
      console.log("\n========================================");
      console.log("MAGIC LINK (Development Fallback)");
      console.log("========================================");
      console.log(`Email: ${email}`);
      console.log(`URL: ${url}`);
      console.log(`Expires: ${expiresAt.toISOString()}`);
      console.log("========================================\n");
    } else {
      // In production, this is a real error
      console.error(`[AUTH] Failed to send magic link email: ${result.error}`);
      throw new Error(`Failed to send magic link email: ${result.error}`);
    }
  }
}

/**
 * Better Auth instance configured for the Dotoro application
 *
 * Features:
 * - Magic link authentication (passwordless login)
 * - OAuth social sign-in (Google, GitHub)
 * - Account linking (multiple auth methods per user)
 * - PostgreSQL database via Drizzle ORM
 * - 7-day session expiry with 24-hour update interval
 *
 * Required environment variables:
 * - BETTER_AUTH_SECRET: Secret key for signing sessions/tokens
 * - BETTER_AUTH_URL: Base URL for the auth server (e.g., http://localhost:3001)
 * - WEB_URL: Frontend URL for trusted origins
 *
 * Optional OAuth environment variables:
 * - AUTH_GOOGLE_CLIENT_ID: Google OAuth client ID
 * - AUTH_GOOGLE_CLIENT_SECRET: Google OAuth client secret
 * - AUTH_GITHUB_CLIENT_ID: GitHub OAuth client ID
 * - AUTH_GITHUB_CLIENT_SECRET: GitHub OAuth client secret
 */
export const auth = betterAuth({
  secret: process.env.BETTER_AUTH_SECRET,
  baseURL: process.env.BETTER_AUTH_URL,
  database: drizzleAdapter(db, {
    provider: "pg",
    // Pass the Better Auth schema tables generated by CLI
    schema: {
      user: schema.user,
      session: schema.session,
      account: schema.account,
      verification: schema.verification,
    },
  }),
  emailAndPassword: {
    enabled: false, // Magic link only - no password authentication
  },
  /**
   * Account Linking Configuration
   *
   * Enables users to link multiple authentication methods (OAuth, magic link)
   * to a single account. When a user authenticates with a provider that returns
   * a verified email matching an existing account, the accounts are linked.
   *
   * Security considerations:
   * - Only trusted providers (Google, GitHub) auto-link on verified email
   * - Users cannot unlink their last auth method to prevent lockout
   * - Different emails are NOT allowed (must match for auto-link)
   *
   * @see https://www.better-auth.com/docs/concepts/users-accounts
   */
  account: {
    accountLinking: {
      enabled: true,
      // Trusted providers will auto-link even if email verification status is uncertain
      trustedProviders: ["google", "github"],
    },
  },
  /**
   * OAuth Social Providers
   *
   * Google and GitHub OAuth are configured here. If the environment
   * variables are not set, the providers will not be available.
   *
   * Callback URLs:
   * - Google: {BETTER_AUTH_URL}/api/auth/callback/google
   * - GitHub: {BETTER_AUTH_URL}/api/auth/callback/github
   */
  socialProviders: {
    // Google OAuth - requires AUTH_GOOGLE_CLIENT_ID and AUTH_GOOGLE_CLIENT_SECRET
    ...(process.env.AUTH_GOOGLE_CLIENT_ID &&
      process.env.AUTH_GOOGLE_CLIENT_SECRET && {
        google: {
          clientId: process.env.AUTH_GOOGLE_CLIENT_ID,
          clientSecret: process.env.AUTH_GOOGLE_CLIENT_SECRET,
        },
      }),
    // GitHub OAuth - requires AUTH_GITHUB_CLIENT_ID and AUTH_GITHUB_CLIENT_SECRET
    ...(process.env.AUTH_GITHUB_CLIENT_ID &&
      process.env.AUTH_GITHUB_CLIENT_SECRET && {
        github: {
          clientId: process.env.AUTH_GITHUB_CLIENT_ID,
          clientSecret: process.env.AUTH_GITHUB_CLIENT_SECRET,
        },
      }),
  },
  plugins: [
    magicLink({
      sendMagicLink,
      expiresIn: 15 * 60, // 15 minutes in seconds
    }),
    admin({
      defaultRole: "user",
      adminRoles: ["admin"],
      impersonationSessionDuration: 3600, // 1 hour in seconds
      defaultBanReason: "Account suspended",
      bannedUserMessage:
        "Your account has been suspended. Contact support for assistance.",
    }),
  ],
  session: {
    expiresIn: 7 * 24 * 60 * 60, // 7 days in seconds
    updateAge: 24 * 60 * 60, // Update session every 24 hours
  },
  trustedOrigins: [process.env.WEB_URL || "http://localhost:3000"],
});

/**
 * Inferred session type from Better Auth
 * Contains both the session object and the user object
 */
export type AuthSession = typeof auth.$Infer.Session;

/**
 * Session object type (the session part of AuthSession)
 * Includes impersonatedBy field when admin plugin is active
 */
export type Session = AuthSession["session"];

/**
 * User object type (the user part of AuthSession)
 * Includes admin fields: role, banned, banReason, banExpires
 */
export type User = AuthSession["user"];

/**
 * Admin role type - the allowed admin roles in the system
 */
export type AdminRole = "admin";

/**
 * User role type - all possible roles
 */
export type UserRole = "user" | AdminRole;

/**
 * Type guard to check if a user has an admin role
 * @param user - The user object to check
 * @returns True if the user has an admin role
 */
export function isAdmin(user: User | null | undefined): boolean {
  return user?.role === "admin";
}

/**
 * Type guard to check if a user is banned
 * @param user - The user object to check
 * @returns True if the user is currently banned
 */
export function isBanned(user: User | null | undefined): boolean {
  if (!user?.banned) return false;

  // Check if ban has expired
  if (user.banExpires) {
    const banExpiresDate = new Date(user.banExpires);
    if (banExpiresDate < new Date()) {
      return false; // Ban has expired
    }
  }

  return true;
}

/**
 * Type guard to check if a session is an impersonation session
 * @param session - The session object to check
 * @returns True if this session is from an admin impersonating a user
 */
export function isImpersonatedSession(
  session: Session | null | undefined
): boolean {
  return !!session?.impersonatedBy;
}
